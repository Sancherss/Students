# Лабораторная работа 2: Процессы и файловая система /proc

**Студент:** Михальчук Александр  
**Группа:** 9  
**Подгруппа:** 1  

## Цель работы

Практическое изучение модели процессов в Linux, механизмов создания и управления процессами, а также исследование виртуальной файловой системы /proc для получения информации о процессах.

## Ход работы

### 1. Создание процессов

Разработана программа на Python, создающая два дочерних процесса с увеличенным временем выполнения для удобства наблюдения.

**Результат вывода:**

```bash
python3 fork.py
parent: PID=5653
child_A: PID=5654, PPID=5653
child_A: работает 15 секунд...
child_A: шаг 1/15
parent: создал процессы 5654 и 5655
child_B: PID=5655, PPID=5653
child_B: работает 10 секунд...
child_B: шаг 1/10
child_B: шаг 2/10
child_A: шаг 2/15
child_B: шаг 3/10
...
child_B: завершается с кодом 20
child_A: шаг 12/15
child_A: шаг 13/15
child_A: шаг 14/15
child_A: шаг 15/15
child_A: завершается с кодом 10
parent: процесс 5654 завершен с кодом 10
parent: процесс 5655 завершен с кодом 20
parent: все процессы завершены

2. Исследование дерева процессов

Во время выполнения программы выполнены команды:
bash

ps -ef --forest | head -n 30 | cat
pstree -p | head -n 50 | cat

Результат:
bash

sancher@Ubuntu:~$ ps -ef --forest | head -n 30 | cat
UID          PID    PPID  C STIME TTY          TIME CMD
root           2       0  0 09:01 ?        00:00:00 [kthreadd]
...

Но они не показали ничего, что связано с нашими процессами. Это скорее всего связано с тем, что приоритет вывода системных процессов. Утилиты ps и pstree по умолчанию сортируют или отображают процессы в таком порядке, что в начале списка оказываются системные процессы (с PID 1, systemd или init и их непосредственные дети, часто запущенные от пользователя root). Процессы обычного пользователя (в моем случае, sancher) показываются значительно ниже. Команда head -n 30 обрезает весь вывод после 30-й строки, и если мои процессы находятся на 35-й или 200-й позиции, они просто не попадают в усеченный вывод. Поэтому используем альтернативные команды для поиска наших процессов:
bash

ps -ef --forest | grep -E "(fork.py|python3)" | head -n 10

Результат:
bash

sancher@Ubuntu:~$ ps -ef --forest | grep -E "(fork.py|python3)" | head -n 10
root        1154       1  0 09:02 ?        00:00:00 /usr/bin/python3 /usr/share/unattended-upgrades/unattended-upgrade-shutdown --wait-for-signal
sancher     5979    4793  0 10:19 pts/0    00:00:00  |   |   \_ python3 fork.py
sancher     5980    5979  0 10:19 pts/0    00:00:00  |   |       \_ python3 fork.py
sancher     5981    5979  0 10:19 pts/0    00:00:00  |   |       \_ python3 fork.py
sancher     5983    5527  0 10:19 pts/1    00:00:00  |       \_ grep --color=auto -E (fork.py|python3)

pstree -p 5979:
bash

sancher@Ubuntu:~$ pstree -p 5979
python3(5979)─┬─python3(5980)
              └─python3(5981)

Вывод: Наглядно видна древовидная структура процессов. Родительский процесс (5979) создал двух дочерних процессов (5980 и 5981), которые отображаются с отступами в выводе ps --forest и в виде дерева в pstree.
3. Изучение файловой системы /proc

Команда: echo $$

Результат:
bash

sancher@Ubuntu:~$ echo $$
5527

Вывод: PID моего текущего bash-сеанса — 5527. Это уникальный идентификатор, который система присвоила моему терминалу.

Команда: cat /proc/5527/cmdline | tr '\0' ' '; echo

Результат:
bash

sancher@Ubuntu:~$ cat /proc/5527/cmdline | tr '\0' ' '; echo
bash

Вывод: Мой текущий процесс bash был запущен просто командой bash, без дополнительных аргументов или скриптов.

Команда: head -n 20 /proc/5527/status

Результат:
bash

sancher@Ubuntu:~$ head -n 20 /proc/5527/status
Name:	bash - имя исполняемого файла
Umask:	0002
State:	S (sleeping) - означает что процесс спит
Tgid:	5527
Ngid:	0
Pid:	5527 - ID процесса
PPid:	4785 - ID процесса-родителя
TracerPid:	0
Uid:	1000	1000	1000	1000
Gid:	1000	1000	1000	1000
FDSize:	256
Groups:	27 1000 
NStgid:	5527
NSpid:	5527
NSpgid:	5527
NSsid:	5527
Kthread:	0
VmPeak:	   19928 kB - Пиковый размер виртуальной памяти процесса 
VmSize:	   19928 kB - Текущий размер виртуальной памяти процесса
VmLck:	       0 kB

Вывод: С помощью данной команды смогли проанализировать ключевые поля статуса процесса.

Команда: ls -l /proc/5527/fd

Результат:
bash

sancher@Ubuntu:~$ ls -l /proc/5527/fd
total 0
lrwx------ 1 sancher sancher 64 Sep 21 10:38 0 -> /dev/pts/1
lrwx------ 1 sancher sancher 64 Sep 21 10:38 1 -> /dev/pts/1
lrwx------ 1 sancher sancher 64 Sep 21 10:38 2 -> /dev/pts/1
lrwx------ 1 sancher sancher 64 Sep 21 10:38 255 -> /dev/pts/1

Вывод: Показывает список файлов в директории fd (file descriptors — файловые дескрипторы). Каждый файл здесь — это симлинк, ведущий на реальный ресурс, открытый процессом. Весь ввод и вывод моего bash-процесса идёт через виртуальное устройство /dev/pts/1. Это подтверждает, что я работаю в терминальной сессии.
4. Анализ нагрузки системы

Топ процессов по CPU

Команда:
bash

ps -eo pid,ppid,comm,state,%cpu,%mem,etime --sort=-%cpu | head -n 15

Результат:
bash

sancher@Ubuntu:~$ ps -eo pid,ppid,comm,state,%cpu,%mem,etime --sort=-%cpu | head -n 15 | cat
    PID    PPID COMMAND         S %CPU %MEM     ELAPSED
   2052    1800 gnome-shell     S 11.1 11.7    02:11:35
   3103    2052 firefox         S  7.2 15.5    02:10:46
   4020    3282 Isolated Web Co S  6.5  8.1    02:10:41
   5715    1800 gnome-text-edit S  3.3  7.1    01:10:29
   ...

Топ процессов по памяти

Команда:
bash

ps -eo pid,ppid,comm,state,%cpu,%mem,rss --sort=-%mem | head -n 15 | cat

Результат:
bash

sancher@Ubuntu:~$ ps -eo pid,ppid,comm,state,%cpu,%mem,rss --sort=-%mem | head -n 15 | cat
    PID    PPID COMMAND         S %CPU %MEM   RSS
   3103    2052 firefox         S  7.2 15.5 621800
   2052    1800 gnome-shell     S 11.1 11.7 472584
   ...

Команда: pidstat -u -r -d 1 5

Результат:
bash

sancher@Ubuntu:~$ pidstat -u -r -d 1 5 
Linux 6.14.0-29-generic (Ubuntu) 	09/21/2025 	_x86_64_	(4 CPU)

11:52:32 AM   UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
...

Вывод: Что нагружает систему: На основании собранных данных, основными процессами, нагружающими систему, являются gnome-shell и firefox. Эти приложения требуют значительных ресурсов, что может быть связано с их функциональностью и количеством открытых вкладок.
Ответы на вопросы

    Чем процесс отличается от программы?

Процесс — это активная версия программы, обладающая собственным состоянием, памятью и ресурсами. Программа — это статичный набор инструкций, который хранится на диске. Один процесс может запускаться несколько раз, в то время как программа не выполняется, пока не станет процессом.

    Что произойдёт, если вызвать fork() без wait()?

Если выполнить fork() без вызова wait(), родительский процесс не будет ждать завершения дочернего. Это может привести к тому, что дочерний процесс станет зомби, так как информация о нём останется в таблице процессов, пока родитель не завершится.

    Как система хранит информацию о процессах?

Информация о процессах хранится в специальной структуре данных, известной как дескриптор процесса (например, task_struct в Linux). Она включает такие данные, как идентификатор процесса (PID), его состояние, приоритет и используемая память.

    Что делает exec() и для чего он нужен?

exec() заменяет текущий процесс на новый, загружая другую программу в его адресное пространство. Это позволяет запускать другой код без создания нового процесса.

    Почему в /proc нет «настоящих» файлов?

В /proc находятся виртуальные файлы, которые не занимают места на диске и не являются физическими файлами. Они служат интерфейсом для доступа к информации о системе и процессах, предоставляемой ядром в реальном времени.

    Как интерпретировать поля top: %CPU, %MEM, VIRT, RES, SHR, TIME+?
        %CPU: процент использования процессора данным процессом.
        %MEM: процент использования оперативной памяти.
        VIRT: объем виртуальной памяти, используемой процессом.
        RES: объем физической памяти, занимаемой процессом.
        SHR: объем общей памяти, используемой совместно с другими процессами.
        TIME+: общее время, затраченное процессом на выполнение.

    Почему сумма %CPU может превышать 100%?

Сумма %CPU может быть больше 100%, если процессор многоядерный. Каждое ядро может использовать до 100% CPU, поэтому в системе с 4 ядрами сумма может достигать 400%.

    Чем мгновенное %CPU отличается от load average? Что означает строка Cpu(s) в top (в т.ч. wa)?
        Мгновенное %CPU: показывает текущую загрузку процессора процессом.
        Load average: усредненная нагрузка системы за последние 1, 5 и 15 минут.
        Строка Cpu(s): демонстрирует состояние процессора, включая:
            us: пользовательский режим,
            sy: системный режим,
            id: простаивающий,
            wa: время ожидания ввода-вывода.

    Чем IO-нагрузка отличается от CPU-нагрузки и как увидеть это (pidstat -d, iotop, /proc/<pid>/io)?

IO-нагрузка связана с операциями чтения и записи на устройства, в то время как CPU-нагрузка — с выполнением инструкций. Для мониторинга IO-нагрузки можно использовать:

- `pidstat -d`: показывает статистику ввода-вывода для процессов.
- `iotop`: отображает активные процессы, использующие IO.
- `/proc/<pid>/io`: предоставляет информацию о вводе-выводе конкретного процесса.

10. Что такое nice/приоритеты процессов и как они влияют на планирование?

Nice-значение — это параметр, определяющий приоритет процесса в планировщике. Низкое значение nice соответствует высокому приоритету, что влияет на распределение CPU между процессами, позволяя более важным процессам получать больше ресурсов.

    Чем поток отличается от процесса и как увидеть потоки в ps/top?

Поток — это легковесная версия процесса, которая делит память с другими потоками в рамках одного процесса. Для просмотра потоков в ps можно использовать опцию -L, а в top — нажатие H для отображения потоков.

    Что такое зомби и сироты, как они возникают и куда «исчезают»?
        Зомби: завершившие выполнение процессы, информация о которых всё еще хранится в таблице процессов, пока родитель не вызовет wait().
        Сироты: процессы, чьи родительские процессы завершились, но они продолжают существовать. Сироты становятся дочерними процессами init, который управляет ими, удаляя их из таблицы процессов.
